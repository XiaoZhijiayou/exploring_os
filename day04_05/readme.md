# 进程调度算法

### 以下这些算法都是非抢占式的，都是运行在单核cpu上的

## 先到先得算法(FCFS) 算法
- 按照进程的到达顺序进行调度，即最先到达的进程最先执行
- 一旦进程开始执行，除非执行完毕，否则不能被中断。换句话说，正在运行的进程会一直占用 CPU，直到它完成。

## 最短任务优先(SJF)算法：就是每一秒扫描一次进程组，选择剩余执行时间最短的进程执行
- 在每一个时刻，算法都会遍历所有已经到达并且没有完成的进程，选择剩余的执行时间最短的进程
- 如果没有进程准备好执行（即所有进程的到达时间都晚于当前时间），我们就将 current_time 增加 1，并继续等待
- 找到最短进程的时候，减少进程组的剩余个数，

```cpp
processes[i].arrival_time <= current_time && 
                remaining_time[i] < shortest_time && 
                remaining_time[i] > 0
```

```
Process Arrival Burst   Waiting Turnaround
1       0       10      13      23
2       1       5       0       5
3       3       8       3       11
```

- 这里面是先运行2，然后是3，最后是1

## 优先级调度算法
- Priority scheduling 为每个进程分配一个 priority 值。首先执行优先级最高（最低数值）的进程。这使得系统关键流程可以立即得到关注。
- 对于平级部分就是还是按照SJF算法来执行

## 循环调度算法
- 循环调度以固定的时间量程间隔分配 CPU 时间。每个进程都会获得公平份额的 CPU 时间，从而防止任何单个进程独占资源。
- 有一个循环周期，每个进程之间相互切换执行，1，2，3这样的时间片执行